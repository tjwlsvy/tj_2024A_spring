
* 인터페이스 : 동일한 목적하의 서로다른기능(오버라이딩)을 수행하기위한 통합.
* 구현(객)체 : 해당 인터페이스를 구현(오버라이딩)한 클래스로 객체 생성
- Collection
    [1] List 인터페이스
        - 공통점 : 저장된 순서(인덱스) 이용한 데이터 관리 , 데이터 중복 허용
        - 1. ArrayList 클래스
            List< 제네릭타입 > 변수명 = new ArrayList<>();          인터페이스 타입일경우 타입변환 수월하다
            ArrayList < 제네릭타입 > list2 = new ArrayList<>();

            - 제네릭타입 : 리스트 객체에 저장할 요소들의 타입
            - 자주 사용되는 메소드
                1. .add( 요소 ) : 리스트내 마지막 인덱스 뒤로 요소 추가
                2. .set( 요소 ) : 리스트내 특정 인덱스의 요소 수정 / 기존 요소 사라짐.
                3. .size()     : 리스트내 요소 개수
                4. .get( 인덱스 ) : 리스트내 특정 인덱스의 요소 값 호출
                5. .contains( 값/객체 ) : 리스트내 특정 값 또는 객체를 검색하여 존재하면 true 없으면 false
                6. .index( 값/객체 ) : 리스트내 특정 값 또는 객체를 검색하여 존재하면 찾은인덱스 없으면 -1
                7. .remove( 값/객체 ) : 리스트내 특정 인덱스 또는 객체가 존재하면 요소 삭제
                8. .clear() : 리스트내 전체 요소 삭제
                9. .isEmpty() : 리스트내 요소가 하나도 없으면 true 요소가 존재하면 false

        - 2. Vector 클래스
            - List 메소드 동기화가 추가된 클래스
            - 멀티스레드를 구현시 사용

        - 3. LinkedList 클래스
            - 중간 삽입/삭제 사용시 ArrayList 보다 좋은 성능을 가진다.

    [2] Set 인터페이스
        - 공통점 : 저장된 순서(인덱스) 없고 , 데이터 중복 허용하지 않는다.
        - 1. HashSet 클래스

        - 자주 사용되는 메소드
            1. .add(요소)    : set 객체내 요소 추가
            2. .size()      : set 객체내 요소 총개수
            3. .remove(요소) : set 객체내 동일한 요소가 존재하면 삭제
            4. . contains(요소) : set 객체내 동일한 요소가 존재하면 true 없으면 false
            5. .clear() : 리스트내 전체 요소 삭제
            6. .isEmpty() : 리스트내 요소가 하나도 없으면 true 요소가 존재하면 false
            7. .iterator() : 반복자 인터페이스 반환
                .hasNext() : 다음 요소가 존재하면 true 없으면 false 받음
                .next() : 다음 요소 호출

        - set 중복을 제거하는 방법 : 객체의 주소값을 비교해서 동일한 주소값은 저장하지 않는다.
            - 리터럴 제외한 객체들을 중복제거
                1. hashCode() 재정의
                    @Override
                        public int hashCode() {
                            return 중복비교기준필드;
                        }
                2. equals() 재정의
                     @Override
                        public boolean equals(Object obj) {
                            if (obj instanceof 클래스명){
                                클래스명 변수명 = (클래스명) obj;
                                if (this.중복비교기준필드 == 변수명.중복비교기준필드){
                                    return true;
                                }else {
                                    return false;
                                }
                            }
                            return false;
                        }


    [3] Map 인터페이스
        - 공통점 : 저장된 순서(인덱스) 없고 , key - value 이루어진 한쌍(엔트리)
        - key : 중복불가능 , value : 중복가능.
        - 1. HashMap 클래스

        - 자주 사용되는 메소드
            1. .put( key , value ) : key 와 value 엔트리 추가
            2. .size() : map 객체내 엔트리 개수
            3. .get( key ) : map 객체내 key 해당하는 value 반환
            4. .remove( key ) : map 객체내 key 해당하는 엔트리 삭제
            5. .clear() : 리스트내 전체 엔트리 삭제
            6. .isEmpty() : 리스트내 엔트리가 하나도 없으면 true 요소가 존재하면 false
            7. .keySet() : map 객체내 모든 key 반환
            8. .values() : map 객체내 모든 value 반환
            9. entrySet() : map 객체내 모든 entry 반환

- 자료구조
    - 컴퓨터 과학에서 * 효율적인 * 자료의 관리, 저장 , 조직하는 방법
    - 왜? 특징 상황기준의 자료들을 정리해두면 검색 , 정렬 , 통계 할때 유용하다.
    - 대표 : 리스트 , 스택 , 큐 , 트리 ,그래프 등등.
    - 사용처 : 프레임워크(java) 2. 기술면접(코딩테스트 , 과제형테스트)

- 스택, 큐
    [1] 스택
        - 데이터를 저장하는 비선형 자료구조( 앞 뒤 데이터가 1:1 관계)
        - 데이터를 저장하는 선형 자료구조
        - Last in First Out : (LIFO)원칙 , 후입선출 , 마지막에 들어온 자료가 가장 먼저 나간다.
        - 일상생활 : 동전케이스 , 프링글스과자상자 , 뒤로가기 기능 , 재귀알고리즘 등등
        - 용어
            1. PUSH : 스택구조에 데이터를 추가하는 연산 , 새로운 데이터는 항상 스택 구조의 맨위에 위치한ㄷ나.
            2. POP : 스택구조에 데이터를 제거하고 반환하는 연산 가장 최근에 추가된 데이터가 반환된다.
            3. TOP : 가장 최근에 추가한 자료의 위치
            4. PEEK : 스택구조의 맨 위에 있는 데이터를 반환 연산 , 제거는 하지 않는다, 스택구조의 최상위 데이터 확인용도 입니다.
        - 자바의 제공 : Stack 클래스
            - Vector 클래스 기반으로 만들어진 클래스
            - 메소드
                1. push() , 2. pop() 3. peek()
    [2] 큐
        - 데이터를 저장하는 비선형 자료구조( 앞 뒤 데이터가 1:1 관계)
        - 데이터를 저장하는 선형 자료구조
        - First int First Out : (FIFO) 원칙 , 선입선출 , 먼저 들어온 자료가 가장 먼저 나간다. 입구/출구 별도로 각 존재한다.
        - 일상생활 : 선착순줄서기 , 프린터기능 , BFS 알고리즘 등등
        - 용어
            1. Enqueue : 큐에 데이터를 추가하는 연산 , 새로운 데이터를 항상 큐의 맨 뒤에 추가된다.
            2. Dequeue : 큐에 데이터를 제거하고 반환하는 연산 , 가장 처음에 추가된 데이터가 제고된다.
            3. peek : 큐의 맨 앞에있는 데이터 반환 , 제거하지는 않는 다첫번째 데이터를 확인용으로 사용한다.
        - 자바의 제공 : Queue 인터페이스
            - LinkedList 클래스의 구현체 필요로 한다.
            - 주요 메소드
                - 1. offer() 2. poll() 3. peek()

- 이진 트리
    - 데이터를 저장하는 비선형 자료구조( 앞 뒤 데이터가 1:N 관계)
    - 각 노드가 최대 2개의 자식 노드를 가질수 있는 트리 구조
    - 왼쪽 자식 노드의 데이터는 부모 노드보다 작다. 오른쪽 자식노드의 데이터는 부모 노드보다 크다.
    - 일상생활 : 데이터 검색 , 정렬 , 파일 시스템 등등
    - 데이터의 오름차순으로 자동으로 제공한다. 내림차순 :  descendingSet() 메소드 이용한다.
        - 왼쪽 -> 부모 -> 오른쪽
    - 용어
        1. 노드 : 데이터가 들어가는 공간
        2. 부모노드 : 특정 노드의 바로 위 노드
        3. 자식노드 : 특정 노드의 바로 아래에 있는 노드들, 이진트리에서는 최대 2개를 가질수 있다.
        4. 루트노드 : 트리의 맨위에 있는 노드로, 루트노드는 시작하는 경로를 통해 접근한다.
        5. 깊이 : 루트노드에서 특정 노드까지의 경로의 길이
        6. 높이 : 트리의 최대 깊이 , 가장 깊은 노드의 길이
    - 자바의 제공 : TreeSet , TreeMap 클래스 제공
        - TreeMap 클래스로 객체를 사용한다.
        - 제네릭에는 Comparable/Comparator 인터페이스를 구현한 구현클래스만 가능하다
        - 메소드
            - Map 메소드의 동일
            1. firstEntry() 2. lastEntry() 3. lowerEntry(데이터) 4. higherEntry(데이터)
            5. floorEntry(데이터) 6. ceilingEntry(데이터)
            7. descendingSetMap()
            8. tailSetMap( 데이터 , true/false )
            9. headSetMap( 데이터 , true/false )
            10. subMap( 시작데이터 , true/false , 끝데이터 , true/false )
        - 정렬기준
            - Comparable 인터페이스 , Comparator 인터페이스
            - TreeSet < 제네릭 > , TreeMap < 제네릭 > 사용해서 Tree 자료구조 구현한다.
            - 제네릭에 들어가는 타입중에 Integer , Double , String 등등 들어간다.
                - JAVA 제공하는 몇몇 클래스에는 이미 Comparable 구현된 상태이다. 주로 리터럴 자료 타입
                - 우리 직접 만든 클래스 Comparable 구현이 안된 상태이다. 직접 만든 클래스도 Comparable 해야된다.
                    1. 클래스 implements Comparable< 클래스 >
                    2. @Override public int compareTo( 클래스 o )























